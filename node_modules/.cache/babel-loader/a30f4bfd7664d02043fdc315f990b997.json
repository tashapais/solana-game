{"ast":null,"code":"import { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport * as splToken from '@solana/spl-token';\nimport crypto from 'crypto';\nimport BN from 'bn.js';\nimport { serialize } from 'borsh';\nimport { Keypair, PublicKey, Transaction, clusterApiUrl, SystemProgram, SYSVAR_RENT_PUBKEY, TransactionInstruction } from \"@solana/web3.js\";\nimport { sleepUtil } from './sleepUtil';\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\nconst METADATA_PROGRAM_ID = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';\nconst MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\nconst programIds = {\n  token: TOKEN_PROGRAM_ID,\n  associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  metadata: METADATA_PROGRAM_ID,\n  memo: MEMO_ID\n};\nexport const NETWORK = clusterApiUrl(\"devnet\");\nexport const AR_SOL_HOLDER_ID = new PublicKey('HvwC9QSAzvGXhhVrgPmauVwFWcYZhne3hVot9EbHuFTm');\nexport const METADATA_PREFIX = 'metadata';\nexport const EDITION = 'edition';\nexport const EDITION_MARKER_BIT_SIZE = 248;\nexport const DEFAULT_TIMEOUT = 15000;\nexport const RESERVED_TXN_MANIFEST = 'manifest.json';\nexport const MetadataKey = {\n  Uninitialized: 0,\n  MetadataV1: 4,\n  EditionV1: 1,\n  MasterEditionV1: 2,\n  MasterEditionV2: 6,\n  EditionMarker: 7\n};\n/**\n * Classes to be used to create the NFT\n */\n\nclass CreateMetadataArgs {\n  constructor(args) {\n    this.instruction = 0;\n    this.data = args.data;\n    this.isMutable = args.isMutable;\n  }\n\n}\n\nclass UpdateMetadataArgs {\n  constructor(args) {\n    this.instruction = 1;\n    this.data = args.data ? args.data : null;\n    this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;\n    this.primarySaleHappened = args.primarySaleHappened;\n  }\n\n}\n\nclass CreateMasterEditionArgs {\n  constructor(args) {\n    this.instruction = 10;\n    this.maxSupply = args.maxSupply;\n  }\n\n}\n\nclass Edition {\n  /// Points at MasterEdition struct\n  /// Starting at 0 for master record, this is incremented for each edition minted.\n  constructor(args) {\n    this.key = MetadataKey.EditionV1;\n    this.parent = args.parent;\n    this.edition = args.edition;\n  }\n\n}\n\nexport class Creator {\n  constructor(args) {\n    this.address = args.address;\n    this.verified = args.verified;\n    this.share = args.share;\n  }\n\n}\n\nclass Data {\n  constructor(args) {\n    this.name = args.name;\n    this.symbol = args.symbol;\n    this.uri = args.uri;\n    this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;\n    this.creators = args.creators;\n  }\n\n}\n\nclass Metadata {\n  // set lazy\n  constructor(args) {\n    this.key = MetadataKey.MetadataV1;\n    this.updateAuthority = args.updateAuthority;\n    this.mint = args.mint;\n    this.data = args.data;\n    this.primarySaleHappened = args.primarySaleHappened;\n    this.isMutable = args.isMutable;\n    this.editionNonce = args.editionNonce;\n  }\n\n  async init() {\n    const edition = await getEdition(this.mint);\n    this.edition = edition;\n    this.masterEdition = edition;\n  }\n\n}\n\nclass MintPrintingTokensArgs {\n  constructor(args) {\n    this.supply = args.supply;\n  }\n\n}\n\nclass MasterEditionV1 {\n  /// Can be used to mint tokens that give one-time permission to mint a single limited edition.\n  /// If you don't know how many printing tokens you are going to need, but you do know\n  /// you are going to need some amount in the future, you can use a token from this mint.\n  /// Coming back to token metadata with one of these tokens allows you to mint (one time)\n  /// any number of printing tokens you want. This is used for instance by Auction Manager\n  /// with participation NFTs, where we dont know how many people will bid and need participation\n  /// printing tokens to redeem, so we give it ONE of these tokens to use after the auction is over,\n  /// because when the auction begins we just dont know how many printing tokens we will need,\n  /// but at the end we will. At the end it then burns this token with token-metadata to\n  /// get the printing tokens it needs to give to bidders. Each bidder then redeems a printing token\n  /// to get their limited editions.\n  constructor(args) {\n    this.key = MetadataKey.MasterEditionV1;\n    this.supply = args.supply;\n    this.maxSupply = args.maxSupply;\n    this.printingMint = args.printingMint;\n    this.oneTimePrintingAuthorizationMint = args.oneTimePrintingAuthorizationMint;\n  }\n\n}\n\nclass MasterEditionV2 {\n  constructor(args) {\n    this.key = MetadataKey.MasterEditionV2;\n    this.supply = args.supply;\n    this.maxSupply = args.maxSupply;\n  }\n\n}\n\nclass EditionMarker {\n  constructor(args) {\n    this.key = MetadataKey.EditionMarker;\n    this.ledger = args.ledger;\n  }\n\n  editionTaken(edition) {\n    const editionOffset = edition % EDITION_MARKER_BIT_SIZE;\n    const indexOffset = Math.floor(editionOffset / 8);\n\n    if (indexOffset > 30) {\n      throw Error('bad index for edition');\n    }\n\n    const positionInBitsetFromRight = 7 - editionOffset % 8;\n    const mask = Math.pow(2, positionInBitsetFromRight);\n    const appliedMask = this.ledger[indexOffset] & mask;\n    return appliedMask != 0;\n  }\n\n}\n/**\n * Helpder function to detect whether Phantom wallet extension installed or not\n * @param {*} connectToWallet \n * @returns \n */\n\n\nexport const connectOrGetPhantomProvider = connectToWallet => {\n  if (\"solana\" in window) {\n    const provider = window.solana;\n\n    if (connectToWallet && !window.solana.isConnected) {\n      window.solana.connect();\n    }\n\n    if (provider.isPhantom) {\n      return provider;\n    }\n  } else if (connectToWallet) {\n    alert(`Please install the phantom wallet from https://phantom.app/`);\n  }\n};\nexport const connectOrGetPhantomProviderTransient = () => {\n  console.log(' connect connectOrGetPhantomProviderTransient called ');\n\n  if (\"solana\" in window) {\n    window.solana.connect({\n      onlyIfTrusted: true\n    });\n  }\n};\n/**\n * Helper function to convert base64 to file object\n * @param {*} dataurl \n * @param {*} filename \n * @returns \n */\n\nexport const dataURLtoFile = (dataurl, filename) => {\n  let arr = dataurl.split(','),\n      mime = arr[0].match(/:(.*?);/)[1],\n      bstr = atob(arr[1]),\n      n = bstr.length,\n      u8arr = new Uint8Array(n);\n\n  while (n--) {\n    u8arr[n] = bstr.charCodeAt(n);\n  }\n\n  return new File([u8arr], filename, {\n    type: mime\n  });\n};\n/**\n * Utility to add functionality to BinaryReader\n */\n\nexport const extendBorsh = () => {\n  BinaryReader.prototype.readPubkey = function () {\n    const reader = this;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n\n  BinaryWriter.prototype.writePubkey = function (value) {\n    const writer = this;\n    writer.writeFixedArray(value.toBuffer());\n  };\n\n  BinaryReader.prototype.readPubkeyAsString = function () {\n    const reader = this;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array);\n  };\n\n  BinaryWriter.prototype.writePubkeyAsString = function (value) {\n    const writer = this;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\nextendBorsh();\nexport const mintNFT = async function (connection, provider, env, files, metadata) {\n  var _result$messages;\n\n  const wallet = provider;\n  const metadataContent = {\n    name: metadata.name,\n    symbol: metadata.symbol,\n    description: metadata.description,\n    seller_fee_basis_points: metadata.sellerFeeBasisPoints,\n    image: metadata.image,\n    animation_url: metadata.animation_url,\n    external_url: metadata.external_url,\n    properties: { ...metadata.properties,\n      creators: metadata.creators.map(creator => {\n        return {\n          address: creator.address,\n          share: creator.share\n        };\n      })\n    }\n  };\n  const realFiles = [...files, new File([JSON.stringify(metadataContent)], 'metadata.json')];\n  const {\n    instructions: pushInstructions,\n    signers: pushSigners\n  } = await prepPayForFilesTxn(wallet, realFiles, metadata); // Allocate memory for the account\n\n  const mintRent = await connection.getMinimumBalanceForRentExemption(splToken.MintLayout.span);\n  const payerPublicKey = wallet.publicKey.toBase58();\n  const instructions = [...pushInstructions];\n  const signers = [...pushSigners]; // This is only temporarily owned by wallet...transferred to program by createMasterEdition below\n\n  const mintKey = createMint(instructions, wallet.publicKey, mintRent, 0, // Some weird bug with phantom where it's public key doesnt mesh with data encode wellff\n  new PublicKey(payerPublicKey), new PublicKey(payerPublicKey), signers).toBase58();\n  const recipientKey = (await findProgramAddress([wallet.publicKey.toBuffer(), programIds.token.toBuffer(), new PublicKey(mintKey).toBuffer()], programIds.associatedToken))[0];\n  createAssociatedTokenAccountInstruction(instructions, new PublicKey(recipientKey), wallet.publicKey, wallet.publicKey, new PublicKey(mintKey));\n  const classData = new Data({\n    symbol: metadata.symbol,\n    name: metadata.name,\n    uri: ' '.repeat(64),\n    // size of url for arweave\n    sellerFeeBasisPoints: metadata.sellerFeeBasisPoints,\n    creators: metadata.creators\n  });\n  const metadataAccount = await createMetadata(classData, payerPublicKey, mintKey, payerPublicKey, instructions, wallet.publicKey.toBase58());\n  const {\n    txid\n  } = await sendTransactionWithRetry(connection, wallet, instructions, signers);\n\n  try {\n    // return\n    await connection.confirmTransaction(txid, 'max');\n  } catch {// ignore\n  }\n\n  await connection.getParsedConfirmedTransaction(txid, 'confirmed');\n  const data = new FormData();\n  const tags = realFiles.reduce((acc, f) => {\n    acc[f.name] = [{\n      name: 'mint',\n      value: mintKey\n    }];\n    return acc;\n  }, {});\n  data.append('tags', JSON.stringify(tags));\n  data.append('transaction', txid);\n  realFiles.map(f => data.append('file[]', f));\n  const result = await (await fetch('https://us-central1-principal-lane-200702.cloudfunctions.net/uploadFile2', {\n    method: 'POST',\n    body: data\n  })).json();\n  const metadataFile = (_result$messages = result.messages) === null || _result$messages === void 0 ? void 0 : _result$messages.find(m => m.filename === RESERVED_TXN_MANIFEST);\n  let arweaveLink = \"\";\n\n  if (metadataFile !== null && metadataFile !== void 0 && metadataFile.transactionId) {\n    const updateInstructions = [];\n    const updateSigners = [];\n    arweaveLink = `https://arweave.net/${metadataFile.transactionId}`;\n    await updateMetadata(new Data({\n      name: metadata.name,\n      symbol: metadata.symbol,\n      uri: arweaveLink,\n      creators: metadata.creators,\n      sellerFeeBasisPoints: metadata.sellerFeeBasisPoints\n    }), undefined, undefined, mintKey, payerPublicKey, updateInstructions, metadataAccount);\n    updateInstructions.push(splToken.Token.createMintToInstruction(TOKEN_PROGRAM_ID, new PublicKey(mintKey), new PublicKey(recipientKey), new PublicKey(payerPublicKey), [], 1));\n    await createMasterEdition(new BN(1), mintKey, payerPublicKey, payerPublicKey, payerPublicKey, updateInstructions);\n    await sendTransactionWithRetry(connection, wallet, updateInstructions, updateSigners);\n  }\n\n  return {\n    metadataAccount,\n    arweaveLink,\n    mintKey,\n    account: recipientKey\n  };\n}; //END the mintNFT\n\n/**\n * \n * @param {*} maxSupply \n * @param {*} mintKey \n * @param {*} updateAuthorityKey \n * @param {*} mintAuthorityKey \n * @param {*} payer \n * @param {*} instructions \n */\n\nasync function createMasterEdition(maxSupply, mintKey, updateAuthorityKey, mintAuthorityKey, payer, instructions) {\n  const metadataProgramId = programIds.metadata;\n  const metadataAccount = (await findProgramAddress([Buffer.from(METADATA_PREFIX), new PublicKey(metadataProgramId).toBuffer(), new PublicKey(mintKey).toBuffer()], new PublicKey(metadataProgramId)))[0];\n  const editionAccount = (await findProgramAddress([Buffer.from(METADATA_PREFIX), new PublicKey(metadataProgramId).toBuffer(), new PublicKey(mintKey).toBuffer(), Buffer.from(EDITION)], new PublicKey(metadataProgramId)))[0];\n  const value = new CreateMasterEditionArgs({\n    maxSupply: maxSupply || null\n  });\n  const data = Buffer.from(serialize(METADATA_SCHEMA, value));\n  const keys = [{\n    pubkey: new PublicKey(editionAccount),\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: new PublicKey(mintKey),\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: new PublicKey(updateAuthorityKey),\n    isSigner: true,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(mintAuthorityKey),\n    isSigner: true,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(payer),\n    isSigner: true,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(metadataAccount),\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: programIds.token,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SystemProgram.programId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  instructions.push(new TransactionInstruction({\n    keys,\n    programId: new PublicKey(metadataProgramId),\n    data\n  }));\n}\n\nconst prepPayForFilesTxn = async (wallet, files, metadata) => {\n  const memo = programIds.memo;\n  const instructions = [];\n  const signers = [];\n  if (wallet.publicKey) instructions.push(SystemProgram.transfer({\n    fromPubkey: wallet.publicKey,\n    toPubkey: AR_SOL_HOLDER_ID,\n    lamports: 100000000\n  })); //Already uploading files on IPFS, hence no files to be transacted here\n\n  for (let i = 0; i < files.length; i++) {\n    const hashSum = crypto.createHash('sha256');\n    hashSum.update(await files[i].text());\n    const hex = hashSum.digest('hex');\n    instructions.push(new TransactionInstruction({\n      keys: [],\n      programId: memo,\n      data: Buffer.from(hex)\n    }));\n  }\n\n  return {\n    instructions,\n    signers\n  };\n};\n\nconst findProgramAddress = async (seeds, programId) => {\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n  return [result[0].toBase58(), result[1]];\n};\n\nfunction createMint(instructions, payer, mintRentExempt, decimals, owner, freezeAuthority, signers) {\n  const account = createUninitializedMint(instructions, payer, mintRentExempt, signers);\n  instructions.push(splToken.Token.createInitMintInstruction(TOKEN_PROGRAM_ID, account, decimals, owner, freezeAuthority));\n  return account;\n}\n\nconst createTokenAccount = (instructions, payer, accountRentExempt, mint, owner, signers) => {\n  const account = createUninitializedAccount(instructions, payer, accountRentExempt, signers);\n  instructions.push(splToken.Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, account, owner));\n  return account;\n};\n\nfunction createUninitializedMint(instructions, payer, amount, signers) {\n  const account = Keypair.generate();\n  instructions.push(SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: account.publicKey,\n    lamports: amount,\n    space: splToken.MintLayout.span,\n    programId: TOKEN_PROGRAM_ID\n  }));\n  signers.push(account);\n  return account.publicKey;\n}\n\nfunction createUninitializedAccount(instructions, payer, amount, signers) {\n  const account = Keypair.generate();\n  instructions.push(SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: account.publicKey,\n    lamports: amount,\n    space: splToken.AccountLayout.span,\n    programId: TOKEN_PROGRAM_ID\n  }));\n  signers.push(account);\n  return account.publicKey;\n}\n\nfunction createAssociatedTokenAccountInstruction(instructions, associatedTokenAddress, payer, walletAddress, splTokenMintAddress) {\n  const keys = [{\n    pubkey: payer,\n    isSigner: true,\n    isWritable: true\n  }, {\n    pubkey: associatedTokenAddress,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: walletAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: splTokenMintAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SystemProgram.programId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: programIds.token,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  instructions.push(new TransactionInstruction({\n    keys,\n    programId: programIds.associatedToken,\n    data: Buffer.from([])\n  }));\n}\n\nconst sendTransactionWithRetry = async function (connection, wallet, instructions, signers) {\n  let commitment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'singleGossip';\n  let includesFeePayer = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let block = arguments.length > 6 ? arguments[6] : undefined;\n  let beforeSend = arguments.length > 7 ? arguments[7] : undefined;\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners( // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const {\n    txid,\n    slot\n  } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction\n  });\n  return {\n    txid,\n    slot\n  };\n};\n\nconst getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nasync function awaitTransactionSignatureConfirmation(txid, timeout, connection) {\n  let commitment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'recent';\n  let queryStatus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({\n        timeout: true\n      });\n    }, timeout);\n\n    try {\n      subId = connection.onSignature(txid, (result, context) => {\n        done = true;\n        status = {\n          err: result.err,\n          slot: context.slot,\n          confirmations: 0\n        };\n\n        if (result.err) {\n          console.log('Rejected via websocket', result.err);\n          reject(status);\n        } else {\n          console.log('Resolved via websocket', result);\n          resolve(status);\n        }\n      }, commitment);\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([txid]);\n          status = signatureStatuses && signatureStatuses.value[0];\n\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n\n      await sleepUtil(1000);\n    }\n  }); //@ts-ignore\n\n  if (connection._signatureSubscriptions[subId]) connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\n\nasync function sendSignedTransaction(_ref) {\n  let {\n    signedTransaction,\n    connection,\n    timeout = DEFAULT_TIMEOUT\n  } = _ref;\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true\n  });\n  console.log('Started awaiting confirmation for', txid);\n  let done = false;\n\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true\n      });\n      await sleepUtil(500);\n    }\n  })();\n\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, timeout, connection, 'recent', true);\n    if (!confirmation) throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n  } catch (err) {// console.error('Timeout Error caught', err);\n    // if (err.timeout) {\n    //   throw new Error('Timed out awaiting confirmation on transaction');\n    // }\n    // let simulateResult: SimulatedTransactionResponse | null = null;\n    // try {\n    //   simulateResult = (\n    //     await simulateTransaction(connection, signedTransaction, 'single')\n    //   ).value;\n    // } catch (e) {}\n    // if (simulateResult && simulateResult.err) {\n    //   if (simulateResult.logs) {\n    //     for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n    //       const line = simulateResult.logs[i];\n    //       if (line.startsWith('Program log: ')) {\n    //         throw new Error(\n    //           'Transaction failed: ' + line.slice('Program log: '.length),\n    //         );\n    //       }\n    //     }\n    //   }\n    //   throw new Error(JSON.stringify(simulateResult.err));\n    // }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return {\n    txid,\n    slot\n  };\n}\n\nasync function getEdition(tokenMint) {\n  return (await findProgramAddress([Buffer.from(METADATA_PREFIX), new PublicKey(programIds.metadata).toBuffer(), new PublicKey(tokenMint).toBuffer(), Buffer.from(EDITION)], new PublicKey(programIds.metadata)))[0];\n}\n\nconst METADATA_SCHEMA = new Map([[CreateMetadataArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['data', Data], ['isMutable', 'u8'] // bool\n  ]\n}], [UpdateMetadataArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['data', {\n    kind: 'option',\n    type: Data\n  }], ['updateAuthority', {\n    kind: 'option',\n    type: 'pubkeyAsString'\n  }], ['primarySaleHappened', {\n    kind: 'option',\n    type: 'u8'\n  }]]\n}], [CreateMasterEditionArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['maxSupply', {\n    kind: 'option',\n    type: 'u64'\n  }]]\n}], [MintPrintingTokensArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['supply', 'u64']]\n}], [MasterEditionV1, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['supply', 'u64'], ['maxSupply', {\n    kind: 'option',\n    type: 'u64'\n  }], ['printingMint', 'pubkeyAsString'], ['oneTimePrintingAuthorizationMint', 'pubkeyAsString']]\n}], [MasterEditionV2, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['supply', 'u64'], ['maxSupply', {\n    kind: 'option',\n    type: 'u64'\n  }]]\n}], [Edition, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['parent', 'pubkeyAsString'], ['edition', 'u64']]\n}], [Data, {\n  kind: 'struct',\n  fields: [['name', 'string'], ['symbol', 'string'], ['uri', 'string'], ['sellerFeeBasisPoints', 'u16'], ['creators', {\n    kind: 'option',\n    type: [Creator]\n  }]]\n}], [Creator, {\n  kind: 'struct',\n  fields: [['address', 'pubkeyAsString'], ['verified', 'u8'], ['share', 'u8']]\n}], [Metadata, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['updateAuthority', 'pubkeyAsString'], ['mint', 'pubkeyAsString'], ['data', Data], ['primarySaleHappened', 'u8'], // bool\n  ['isMutable', 'u8'] // bool\n  ]\n}], [EditionMarker, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['ledger', [31]]]\n}]]);\n\nasync function createMetadata(data, updateAuthority, mintKey, mintAuthorityKey, instructions, payer) {\n  const metadataProgramId = programIds.metadata;\n  const metadataAccount = (await findProgramAddress([Buffer.from('metadata'), new PublicKey(metadataProgramId).toBuffer(), new PublicKey(mintKey).toBuffer()], new PublicKey(metadataProgramId)))[0];\n  const value = new CreateMetadataArgs({\n    data,\n    isMutable: true\n  });\n  let txnData = Buffer.from(serialize(METADATA_SCHEMA, value));\n  ;\n  const keys = [{\n    pubkey: new PublicKey(metadataAccount),\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: new PublicKey(mintKey),\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(mintAuthorityKey),\n    isSigner: true,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(payer),\n    isSigner: true,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(updateAuthority),\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SystemProgram.programId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  instructions.push(new TransactionInstruction({\n    keys,\n    programId: new PublicKey(metadataProgramId),\n    data: txnData\n  }));\n  return metadataAccount;\n}\n\nasync function updateMetadata(data, newUpdateAuthority, primarySaleHappened, mintKey, updateAuthority, instructions, metadataAccount) {\n  const metadataProgramId = programIds.metadata;\n  metadataAccount = metadataAccount || (await findProgramAddress([Buffer.from('metadata'), new PublicKey(metadataProgramId).toBuffer(), new PublicKey(mintKey).toBuffer()], new PublicKey(metadataProgramId)))[0];\n  const value = new UpdateMetadataArgs({\n    data,\n    updateAuthority: !newUpdateAuthority ? undefined : newUpdateAuthority,\n    primarySaleHappened: primarySaleHappened === null || primarySaleHappened === undefined ? null : primarySaleHappened\n  });\n  const txnData = Buffer.from(serialize(METADATA_SCHEMA, value));\n  const keys = [{\n    pubkey: new PublicKey(metadataAccount),\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: new PublicKey(updateAuthority),\n    isSigner: true,\n    isWritable: false\n  }];\n  instructions.push(new TransactionInstruction({\n    keys,\n    programId: new PublicKey(metadataProgramId),\n    data: txnData\n  }));\n  return metadataAccount;\n}","map":{"version":3,"sources":["/Users/tashapais/Documents/Github/solana-games/src/utils/nftCreation.js"],"names":["BinaryReader","BinaryWriter","base58","splToken","crypto","BN","serialize","Keypair","PublicKey","Transaction","clusterApiUrl","SystemProgram","SYSVAR_RENT_PUBKEY","TransactionInstruction","sleepUtil","TOKEN_PROGRAM_ID","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","METADATA_PROGRAM_ID","MEMO_ID","programIds","token","associatedToken","metadata","memo","NETWORK","AR_SOL_HOLDER_ID","METADATA_PREFIX","EDITION","EDITION_MARKER_BIT_SIZE","DEFAULT_TIMEOUT","RESERVED_TXN_MANIFEST","MetadataKey","Uninitialized","MetadataV1","EditionV1","MasterEditionV1","MasterEditionV2","EditionMarker","CreateMetadataArgs","constructor","args","instruction","data","isMutable","UpdateMetadataArgs","updateAuthority","primarySaleHappened","CreateMasterEditionArgs","maxSupply","Edition","key","parent","edition","Creator","address","verified","share","Data","name","symbol","uri","sellerFeeBasisPoints","creators","Metadata","mint","editionNonce","init","getEdition","masterEdition","MintPrintingTokensArgs","supply","printingMint","oneTimePrintingAuthorizationMint","ledger","editionTaken","editionOffset","indexOffset","Math","floor","Error","positionInBitsetFromRight","mask","pow","appliedMask","connectOrGetPhantomProvider","connectToWallet","window","provider","solana","isConnected","connect","isPhantom","alert","connectOrGetPhantomProviderTransient","console","log","onlyIfTrusted","dataURLtoFile","dataurl","filename","arr","split","mime","match","bstr","atob","n","length","u8arr","Uint8Array","charCodeAt","File","type","extendBorsh","prototype","readPubkey","reader","array","readFixedArray","writePubkey","value","writer","writeFixedArray","toBuffer","readPubkeyAsString","encode","writePubkeyAsString","decode","mintNFT","connection","env","files","wallet","metadataContent","description","seller_fee_basis_points","image","animation_url","external_url","properties","map","creator","realFiles","JSON","stringify","instructions","pushInstructions","signers","pushSigners","prepPayForFilesTxn","mintRent","getMinimumBalanceForRentExemption","MintLayout","span","payerPublicKey","publicKey","toBase58","mintKey","createMint","recipientKey","findProgramAddress","createAssociatedTokenAccountInstruction","classData","repeat","metadataAccount","createMetadata","txid","sendTransactionWithRetry","confirmTransaction","getParsedConfirmedTransaction","FormData","tags","reduce","acc","f","append","result","fetch","method","body","json","metadataFile","messages","find","m","arweaveLink","transactionId","updateInstructions","updateSigners","updateMetadata","undefined","push","Token","createMintToInstruction","createMasterEdition","account","updateAuthorityKey","mintAuthorityKey","payer","metadataProgramId","Buffer","from","editionAccount","METADATA_SCHEMA","keys","pubkey","isSigner","isWritable","programId","transfer","fromPubkey","toPubkey","lamports","i","hashSum","createHash","update","text","hex","digest","seeds","mintRentExempt","decimals","owner","freezeAuthority","createUninitializedMint","createInitMintInstruction","createTokenAccount","accountRentExempt","createUninitializedAccount","createInitAccountInstruction","amount","generate","createAccount","newAccountPubkey","space","AccountLayout","associatedTokenAddress","walletAddress","splTokenMintAddress","commitment","includesFeePayer","block","beforeSend","transaction","forEach","add","recentBlockhash","getRecentBlockhash","blockhash","setSigners","s","partialSign","signTransaction","slot","sendSignedTransaction","signedTransaction","getUnixTs","Date","getTime","awaitTransactionSignatureConfirmation","timeout","queryStatus","done","status","confirmations","err","subId","Promise","resolve","reject","setTimeout","onSignature","context","e","error","signatureStatuses","getSignatureStatuses","_signatureSubscriptions","removeSignatureListener","rawTransaction","startTime","sendRawTransaction","skipPreflight","confirmation","tokenMint","Map","kind","fields","txnData","newUpdateAuthority"],"mappings":"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","sourcesContent":["import { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport * as splToken from '@solana/spl-token'\nimport crypto from 'crypto';\nimport BN from 'bn.js';\nimport { serialize } from 'borsh';\nimport {\n    Keypair,\n      PublicKey,\n      Transaction,\n      clusterApiUrl,\n      SystemProgram,\n      SYSVAR_RENT_PUBKEY,\n      TransactionInstruction\n    } from \"@solana/web3.js\";\nimport { sleepUtil } from './sleepUtil';\n\nexport const TOKEN_PROGRAM_ID = new PublicKey(\n  'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n);\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey(\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n);\n\nconst METADATA_PROGRAM_ID =\n    'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';\n\nconst MEMO_ID = new PublicKey(\n  'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr',\n);\n\nconst programIds = {\n  token: TOKEN_PROGRAM_ID,\n  associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  metadata: METADATA_PROGRAM_ID,\n  memo: MEMO_ID,\n}\n\nexport const NETWORK = clusterApiUrl(\"devnet\");\nexport const AR_SOL_HOLDER_ID = new PublicKey(\n    'HvwC9QSAzvGXhhVrgPmauVwFWcYZhne3hVot9EbHuFTm',\n);\nexport const METADATA_PREFIX = 'metadata';\nexport const EDITION = 'edition';\nexport const EDITION_MARKER_BIT_SIZE = 248;\nexport const DEFAULT_TIMEOUT = 15000;\nexport const RESERVED_TXN_MANIFEST = 'manifest.json';\nexport const MetadataKey = {\n    Uninitialized : 0,\n    MetadataV1 : 4,\n    EditionV1 : 1,\n    MasterEditionV1 : 2,\n    MasterEditionV2 : 6,\n    EditionMarker : 7,\n}\n\n/**\n * Classes to be used to create the NFT\n */\n\n class CreateMetadataArgs {\n    instruction= 0;\n    data;\n    isMutable;\n  \n    constructor(args) {\n      this.data = args.data;\n      this.isMutable = args.isMutable;\n    }\n  }\n\n  class UpdateMetadataArgs {\n    instruction= 1;\n    data;\n    // Not used by this app, just required for instruction\n    updateAuthority;\n    primarySaleHappened;\n    constructor(args) {\n      this.data = args.data ? args.data : null;\n      this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;\n      this.primarySaleHappened = args.primarySaleHappened;\n    }\n  }\n\n  class CreateMasterEditionArgs {\n    instruction = 10;\n    maxSupply;\n    constructor(args) {\n      this.maxSupply = args.maxSupply;\n    }\n  }\n\n  class Edition {\n    key;\n    /// Points at MasterEdition struct\n    parent;\n    /// Starting at 0 for master record, this is incremented for each edition minted.\n    edition;\n  \n    constructor(args) {\n      this.key = MetadataKey.EditionV1;\n      this.parent = args.parent;\n      this.edition = args.edition;\n    }\n  }\n  export class Creator {\n    address;\n    verified;\n    share;\n  \n    constructor(args) {\n      this.address = args.address;\n      this.verified = args.verified;\n      this.share = args.share;\n    }\n  }\n  \n  class Data {\n    name;\n    symbol;\n    uri;\n    sellerFeeBasisPoints;\n    creators;\n    constructor(args) {\n      this.name = args.name;\n      this.symbol = args.symbol;\n      this.uri = args.uri;\n      this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;\n      this.creators = args.creators;\n    }\n  }\n  \n  class Metadata {\n    key;\n    updateAuthority;\n    mint;\n    data;\n    primarySaleHappened;\n    isMutable;\n    editionNonce;\n  \n    // set lazy\n    masterEdition;\n    edition;\n  \n    constructor(args) {\n      this.key = MetadataKey.MetadataV1;\n      this.updateAuthority = args.updateAuthority;\n      this.mint = args.mint;\n      this.data = args.data;\n      this.primarySaleHappened = args.primarySaleHappened;\n      this.isMutable = args.isMutable;\n      this.editionNonce = args.editionNonce;\n    }\n  \n    async init() {\n      const edition = await getEdition(this.mint);\n      this.edition = edition;\n      this.masterEdition = edition;\n    }\n  }\n\n  class MintPrintingTokensArgs {\n    instruction9;\n    supply;\n  \n    constructor(args) {\n      this.supply = args.supply;\n    }\n  }\n\n  class MasterEditionV1 {\n    key;\n    supply;\n    maxSupply;\n    /// Can be used to mint tokens that give one-time permission to mint a single limited edition.\n    printingMint;\n    /// If you don't know how many printing tokens you are going to need, but you do know\n    /// you are going to need some amount in the future, you can use a token from this mint.\n    /// Coming back to token metadata with one of these tokens allows you to mint (one time)\n    /// any number of printing tokens you want. This is used for instance by Auction Manager\n    /// with participation NFTs, where we dont know how many people will bid and need participation\n    /// printing tokens to redeem, so we give it ONE of these tokens to use after the auction is over,\n    /// because when the auction begins we just dont know how many printing tokens we will need,\n    /// but at the end we will. At the end it then burns this token with token-metadata to\n    /// get the printing tokens it needs to give to bidders. Each bidder then redeems a printing token\n    /// to get their limited editions.\n    oneTimePrintingAuthorizationMint;\n  \n    constructor(args) {\n      this.key = MetadataKey.MasterEditionV1;\n      this.supply = args.supply;\n      this.maxSupply = args.maxSupply;\n      this.printingMint = args.printingMint;\n      this.oneTimePrintingAuthorizationMint =\n        args.oneTimePrintingAuthorizationMint;\n    }\n  }\n  \n  class MasterEditionV2 {\n    key;\n    supply;\n    maxSupply;\n  \n    constructor(args) {\n      this.key = MetadataKey.MasterEditionV2;\n      this.supply = args.supply;\n      this.maxSupply = args.maxSupply;\n    }\n  }\n\n  class EditionMarker {\n    key;\n    ledger;\n  \n    constructor(args) {\n      this.key = MetadataKey.EditionMarker;\n      this.ledger = args.ledger;\n    }\n  \n    editionTaken(edition) {\n      const editionOffset = edition % EDITION_MARKER_BIT_SIZE;\n      const indexOffset = Math.floor(editionOffset / 8);\n  \n      if (indexOffset > 30) {\n        throw Error('bad index for edition');\n      }\n  \n      const positionInBitsetFromRight = 7 - (editionOffset % 8);\n  \n      const mask = Math.pow(2, positionInBitsetFromRight);\n  \n      const appliedMask = this.ledger[indexOffset] & mask;\n  \n      return appliedMask != 0;\n    }\n  }\n\n\n\n/**\n * Helpder function to detect whether Phantom wallet extension installed or not\n * @param {*} connectToWallet \n * @returns \n */\nexport const connectOrGetPhantomProvider = (connectToWallet) => {\n    if (\"solana\" in window) {\n      const provider = window.solana;\n      if(connectToWallet && !window.solana.isConnected){\n            window.solana.connect();\n        }\n        if (provider.isPhantom) {\n            return provider;\n        }\n    }else if(connectToWallet){\n      alert(`Please install the phantom wallet from https://phantom.app/`);\n    }\n    \n};\n\nexport const connectOrGetPhantomProviderTransient = () => {\n  console.log(' connect connectOrGetPhantomProviderTransient called ')\n  if (\"solana\" in window) {\n          window.solana.connect({ onlyIfTrusted: true });\n  }\n}\n\n/**\n * Helper function to convert base64 to file object\n * @param {*} dataurl \n * @param {*} filename \n * @returns \n */\nexport const dataURLtoFile = (dataurl, filename) => {\n    let arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],\n        bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);\n        while(n--){\n            u8arr[n] = bstr.charCodeAt(n);\n        }\n        return new File([u8arr], filename, {type:mime});\n}\n\n/**\n * Utility to add functionality to BinaryReader\n */\nexport const extendBorsh = () => {\n(BinaryReader.prototype).readPubkey = function () {\n    const reader = this;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n};\n\n(BinaryWriter.prototype).writePubkey = function (value) {\n    const writer = this;\n    writer.writeFixedArray(value.toBuffer());\n};\n\n(BinaryReader.prototype).readPubkeyAsString = function () {\n    const reader = this;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array);\n};\n\n(BinaryWriter.prototype).writePubkeyAsString = function (\n    value,\n) {\n    const writer = this;\n    writer.writeFixedArray(base58.decode(value));\n};\n};\nextendBorsh();\n\n\n\n\n  export const mintNFT = async function(\n    connection,\n    provider,\n    env,\n    files,\n    metadata){\n\n    const wallet = provider\n    const metadataContent = {\n          name: metadata.name,\n          symbol: metadata.symbol,\n          description: metadata.description,\n          seller_fee_basis_points: metadata.sellerFeeBasisPoints,\n          image: metadata.image,\n          animation_url: metadata.animation_url,\n          external_url: metadata.external_url,\n          properties: {\n            ...metadata.properties,\n            creators: metadata.creators.map(creator => {\n              return {\n                address: creator.address,\n                share: creator.share,\n              };\n            }),\n          },\n      };\n    const realFiles = [\n      ...files,\n      new File([JSON.stringify(metadataContent)], 'metadata.json'),\n    ];\n\n    const { instructions: pushInstructions, signers: pushSigners } = await prepPayForFilesTxn(wallet, realFiles, metadata);\n\n\n     // Allocate memory for the account\n    const mintRent = await connection.getMinimumBalanceForRentExemption(\n      splToken.MintLayout.span\n    );\n\n    const payerPublicKey = wallet.publicKey.toBase58();\n    const instructions = [...pushInstructions];\n    const signers = [...pushSigners];\n\n     // This is only temporarily owned by wallet...transferred to program by createMasterEdition below\n    const mintKey = createMint(\n      instructions,\n      wallet.publicKey,\n      mintRent,\n      0,\n      // Some weird bug with phantom where it's public key doesnt mesh with data encode wellff\n      new PublicKey(payerPublicKey),\n      new PublicKey(payerPublicKey),\n      signers,\n    ).toBase58();\n\n    const recipientKey = (\n      await findProgramAddress(\n        [\n          wallet.publicKey.toBuffer(),\n          programIds.token.toBuffer(),\n          new PublicKey(mintKey).toBuffer(),\n        ],\n        programIds.associatedToken,\n      )\n    )[0];\n\n    createAssociatedTokenAccountInstruction(\n      instructions,\n      new PublicKey(recipientKey),\n      wallet.publicKey,\n      wallet.publicKey,\n      new PublicKey(mintKey),\n    );\n    const classData = new Data({\n      symbol: metadata.symbol,\n      name: metadata.name,\n      uri:' '.repeat(64), // size of url for arweave\n      sellerFeeBasisPoints: metadata.sellerFeeBasisPoints,\n      creators: metadata.creators,\n    })\n    const metadataAccount = await createMetadata(\n      classData,\n      payerPublicKey,\n      mintKey,\n      payerPublicKey,\n      instructions,\n      wallet.publicKey.toBase58(),\n    );\n    const { txid } = await sendTransactionWithRetry(\n      connection,\n      wallet,\n      instructions,\n      signers,\n    );\n    try {\n      // return\n     await connection.confirmTransaction(txid, 'max');\n    } catch {\n      // ignore\n    }\n\n    await connection.getParsedConfirmedTransaction(txid, 'confirmed');\n\n    const data = new FormData();\n\n    const tags = realFiles.reduce(\n      (acc, f) => {\n        acc[f.name] = [{ name: 'mint', value: mintKey }];\n        return acc;\n      },\n      {},\n    );\n    data.append('tags', JSON.stringify(tags));\n    data.append('transaction', txid);\n    realFiles.map(f => data.append('file[]', f));\n\n    const result = await (\n      await fetch(\n        'https://us-central1-principal-lane-200702.cloudfunctions.net/uploadFile2',\n        {\n          method: 'POST',\n          body: data,\n        },\n      )\n    ).json();\n\n    const metadataFile = result.messages?.find(\n      m => m.filename === RESERVED_TXN_MANIFEST,\n    );\n    let arweaveLink = \"\"\n    if(metadataFile?.transactionId){\n      const updateInstructions = [];\n    const updateSigners= [];\n    arweaveLink = `https://arweave.net/${metadataFile.transactionId}`;\n    await updateMetadata(\n      new Data({\n        name: metadata.name,\n        symbol: metadata.symbol,\n        uri: arweaveLink,\n        creators: metadata.creators,\n        sellerFeeBasisPoints: metadata.sellerFeeBasisPoints,\n      }),\n      undefined,\n      undefined,\n      mintKey,\n      payerPublicKey,\n      updateInstructions,\n      metadataAccount,\n    );\n\n    updateInstructions.push(\n      splToken.Token.createMintToInstruction(\n        TOKEN_PROGRAM_ID,\n        new PublicKey(mintKey),\n        new PublicKey(recipientKey),\n        new PublicKey(payerPublicKey),\n        [],\n        1,\n      ),\n    );\n\n    await createMasterEdition(\n      new BN(1),\n      mintKey,\n      payerPublicKey,\n      payerPublicKey,\n      payerPublicKey,\n      updateInstructions,\n    );\n\n    await sendTransactionWithRetry(\n      connection,\n      wallet,\n      updateInstructions,\n      updateSigners,\n    );}\n    return { metadataAccount, arweaveLink, mintKey, account: recipientKey };\n  }\n\n  //END the mintNFT\n\n  /**\n   * \n   * @param {*} maxSupply \n   * @param {*} mintKey \n   * @param {*} updateAuthorityKey \n   * @param {*} mintAuthorityKey \n   * @param {*} payer \n   * @param {*} instructions \n   */\n\n  async function createMasterEdition(\n    maxSupply,\n    mintKey,\n    updateAuthorityKey,\n    mintAuthorityKey,\n    payer,\n    instructions,\n  ) {\n    const metadataProgramId = programIds.metadata;\n  \n    const metadataAccount = (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          new PublicKey(metadataProgramId).toBuffer(),\n          new PublicKey(mintKey).toBuffer(),\n        ],\n        new PublicKey(metadataProgramId),\n      )\n    )[0];\n  \n    const editionAccount = (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          new PublicKey(metadataProgramId).toBuffer(),\n          new PublicKey(mintKey).toBuffer(),\n          Buffer.from(EDITION),\n        ],\n        new PublicKey(metadataProgramId),\n      )\n    )[0];\n  \n    const value = new CreateMasterEditionArgs({ maxSupply: maxSupply || null });\n    const data = Buffer.from(serialize(METADATA_SCHEMA, value));\n  \n    const keys = [\n      {\n        pubkey: new PublicKey(editionAccount),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: new PublicKey(mintKey),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: new PublicKey(updateAuthorityKey),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(mintAuthorityKey),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(payer),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(metadataAccount),\n        isSigner: false,\n        isWritable: false,\n      },\n  \n      {\n        pubkey: programIds.token,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n  \n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: new PublicKey(metadataProgramId),\n        data,\n      }),\n    );\n  }\n\n  const prepPayForFilesTxn = async (\n    wallet,\n    files,\n    metadata,\n  ) => {\n    const memo = programIds.memo;\n  \n    const instructions= [];\n    const signers= [];\n  \n    if (wallet.publicKey)\n      instructions.push(\n        SystemProgram.transfer({\n          fromPubkey: wallet.publicKey,\n          toPubkey: AR_SOL_HOLDER_ID,\n          lamports: 100000000,\n        }),\n      );\n  \n    //Already uploading files on IPFS, hence no files to be transacted here\n    for (let i = 0; i < files.length; i++) {\n      const hashSum = crypto.createHash('sha256');\n      hashSum.update(await files[i].text());\n      const hex = hashSum.digest('hex');\n      instructions.push(\n        new TransactionInstruction({\n          keys: [],\n          programId: memo,\n          data: Buffer.from(hex),\n        }),\n      );\n    }\n  \n    return {\n      instructions,\n      signers,\n    };\n  };\n\n  const findProgramAddress = async (\n    seeds,\n    programId,\n  ) => {\n    const result = await PublicKey.findProgramAddress(seeds, programId);\n    return [result[0].toBase58(), result[1]];\n  };\n\n  function createMint(\n    instructions,\n    payer,\n    mintRentExempt,\n    decimals,\n    owner,\n    freezeAuthority,\n    signers,\n  ) {\n    const account = createUninitializedMint(\n      instructions,\n      payer,\n      mintRentExempt,\n      signers,\n    );\n  \n    instructions.push(\n      splToken.Token.createInitMintInstruction(\n        TOKEN_PROGRAM_ID,\n        account,\n        decimals,\n        owner,\n        freezeAuthority,\n      ),\n    );\n  \n    return account;\n  }\n\n  const createTokenAccount =(\n    instructions,\n    payer,\n    accountRentExempt,\n    mint,\n    owner,\n    signers,\n  ) => {\n    const account = createUninitializedAccount(\n      instructions,\n      payer,\n      accountRentExempt,\n      signers,\n    );\n  \n    instructions.push(\n      splToken.Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, account, owner),\n    );\n  \n    return account;\n  }\n\n  function createUninitializedMint(\n    instructions,\n    payer,\n    amount,\n    signers,\n  ) {\n    const account = Keypair.generate();\n    instructions.push(\n      SystemProgram.createAccount({\n        fromPubkey: payer,\n        newAccountPubkey: account.publicKey,\n        lamports: amount,\n        space: splToken.MintLayout.span,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n    );\n  \n    signers.push(account);\n  \n    return account.publicKey;\n  }\n\n  function createUninitializedAccount(\n    instructions,\n    payer,\n    amount,\n    signers,\n  ) {\n    const account = Keypair.generate();\n    instructions.push(\n      SystemProgram.createAccount({\n        fromPubkey: payer,\n        newAccountPubkey: account.publicKey,\n        lamports: amount,\n        space: splToken.AccountLayout.span,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n    );\n  \n    signers.push(account);\n  \n    return account.publicKey;\n  }\n\n  function createAssociatedTokenAccountInstruction(\n    instructions,\n    associatedTokenAddress,\n    payer,\n    walletAddress,\n    splTokenMintAddress,\n  ) {\n    const keys = [\n      {\n        pubkey: payer,\n        isSigner: true,\n        isWritable: true,\n      },\n      {\n        pubkey: associatedTokenAddress,\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: walletAddress,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: splTokenMintAddress,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: programIds.token,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: programIds.associatedToken,\n        data: Buffer.from([]),\n      }),\n    );\n  }\n\n  const sendTransactionWithRetry = async (\n    connection,\n    wallet,\n    instructions,\n    signers,\n    commitment = 'singleGossip',\n    includesFeePayer = false,\n    block,\n    beforeSend,\n  ) => {\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = (\n      block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n  \n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n    }\n  \n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  \n    if (beforeSend) {\n      beforeSend();\n    }\n  \n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n  \n    return { txid, slot };\n  };\n  const getUnixTs = () => {\n    return new Date().getTime() / 1000;\n  };\n\n  async function awaitTransactionSignatureConfirmation(\n    txid,\n    timeout,\n    connection,\n    commitment = 'recent',\n    queryStatus = false,\n  ) {\n    let done = false;\n    let status = {\n      slot: 0,\n      confirmations: 0,\n      err: null,\n    };\n    let subId = 0;\n    status = await new Promise(async (resolve, reject) => {\n      setTimeout(() => {\n        if (done) {\n          return;\n        }\n        done = true;\n        console.log('Rejecting for timeout...');\n        reject({ timeout: true });\n      }, timeout);\n      try {\n        subId = connection.onSignature(\n          txid,\n          (result, context) => {\n            done = true;\n            status = {\n              err: result.err,\n              slot: context.slot,\n              confirmations: 0,\n            };\n            if (result.err) {\n              console.log('Rejected via websocket', result.err);\n              reject(status);\n            } else {\n              console.log('Resolved via websocket', result);\n              resolve(status);\n            }\n          },\n          commitment,\n        );\n      } catch (e) {\n        done = true;\n        console.error('WS error in setup', txid, e);\n      }\n      while (!done && queryStatus) {\n        // eslint-disable-next-line no-loop-func\n        (async () => {\n          try {\n            const signatureStatuses = await connection.getSignatureStatuses([\n              txid,\n            ]);\n            status = signatureStatuses && signatureStatuses.value[0];\n            if (!done) {\n              if (!status) {\n                console.log('REST null result for', txid, status);\n              } else if (status.err) {\n                console.log('REST error for', txid, status);\n                done = true;\n                reject(status.err);\n              } else if (!status.confirmations) {\n                console.log('REST no confirmations for', txid, status);\n              } else {\n                console.log('REST confirmation for', txid, status);\n                done = true;\n                resolve(status);\n              }\n            }\n          } catch (e) {\n            if (!done) {\n              console.log('REST connection error: txid', txid, e);\n            }\n          }\n        })();\n        await sleepUtil(1000);\n      }\n    });\n  \n    //@ts-ignore\n    if (connection._signatureSubscriptions[subId])\n      connection.removeSignatureListener(subId);\n    done = true;\n    console.log('Returning status', status);\n    return status;\n  }\n\n  async function sendSignedTransaction({\n    signedTransaction,\n    connection,\n    timeout = DEFAULT_TIMEOUT,\n  }){\n    const rawTransaction = signedTransaction.serialize();\n    const startTime = getUnixTs();\n    let slot = 0;\n    const txid = await connection.sendRawTransaction(\n      rawTransaction,\n      {\n        skipPreflight: true,\n      },\n    );\n  \n    console.log('Started awaiting confirmation for', txid);\n  \n    let done = false;\n    (async () => {\n      while (!done && getUnixTs() - startTime < timeout) {\n        connection.sendRawTransaction(rawTransaction, {\n          skipPreflight: true,\n        });\n        await sleepUtil(500);\n      }\n    })();\n    try {\n      const confirmation = await awaitTransactionSignatureConfirmation(\n        txid,\n        timeout,\n        connection,\n        'recent',\n        true,\n      );\n  \n      if (!confirmation)\n        throw new Error('Timed out awaiting confirmation on transaction');\n  \n      if (confirmation.err) {\n        console.error(confirmation.err);\n        throw new Error('Transaction failed: Custom instruction error');\n      }\n  \n      slot = confirmation?.slot || 0;\n    } catch (err) {\n      // console.error('Timeout Error caught', err);\n      // if (err.timeout) {\n      //   throw new Error('Timed out awaiting confirmation on transaction');\n      // }\n      // let simulateResult: SimulatedTransactionResponse | null = null;\n      // try {\n      //   simulateResult = (\n      //     await simulateTransaction(connection, signedTransaction, 'single')\n      //   ).value;\n      // } catch (e) {}\n      // if (simulateResult && simulateResult.err) {\n      //   if (simulateResult.logs) {\n      //     for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n      //       const line = simulateResult.logs[i];\n      //       if (line.startsWith('Program log: ')) {\n      //         throw new Error(\n      //           'Transaction failed: ' + line.slice('Program log: '.length),\n      //         );\n      //       }\n      //     }\n      //   }\n      //   throw new Error(JSON.stringify(simulateResult.err));\n      // }\n      // throw new Error('Transaction failed');\n    } finally {\n      done = true;\n    }\n  \n    console.log('Latency', txid, getUnixTs() - startTime);\n    return { txid, slot };\n  }\n\n  async function getEdition(\n    tokenMint,\n  ){    \n    return (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          new PublicKey(programIds.metadata).toBuffer(),\n          new PublicKey(tokenMint).toBuffer(),\n          Buffer.from(EDITION),\n        ],\n        new PublicKey(programIds.metadata),\n      )\n    )[0];\n  }\n  \n  const METADATA_SCHEMA = new Map([\n    [\n      CreateMetadataArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['data', Data],\n          ['isMutable', 'u8'], // bool\n        ],\n      },\n    ],\n    [\n      UpdateMetadataArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['data', { kind: 'option', type: Data }],\n          ['updateAuthority', { kind: 'option', type: 'pubkeyAsString' }],\n          ['primarySaleHappened', { kind: 'option', type: 'u8' }],\n        ],\n      },\n    ],\n  \n    [\n      CreateMasterEditionArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['maxSupply', { kind: 'option', type: 'u64' }],\n        ],\n      },\n    ],\n    [\n      MintPrintingTokensArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['supply', 'u64'],\n        ],\n      },\n    ],\n    [\n      MasterEditionV1,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['supply', 'u64'],\n          ['maxSupply', { kind: 'option', type: 'u64' }],\n          ['printingMint', 'pubkeyAsString'],\n          ['oneTimePrintingAuthorizationMint', 'pubkeyAsString'],\n        ],\n      },\n    ],\n    [\n      MasterEditionV2,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['supply', 'u64'],\n          ['maxSupply', { kind: 'option', type: 'u64' }],\n        ],\n      },\n    ],\n    [\n      Edition,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['parent', 'pubkeyAsString'],\n          ['edition', 'u64'],\n        ],\n      },\n    ],\n    [\n      Data,\n      {\n        kind: 'struct',\n        fields: [\n          ['name', 'string'],\n          ['symbol', 'string'],\n          ['uri', 'string'],\n          ['sellerFeeBasisPoints', 'u16'],\n          ['creators', { kind: 'option', type: [Creator] }],\n        ],\n      },\n    ],\n    [\n      Creator,\n      {\n        kind: 'struct',\n        fields: [\n          ['address', 'pubkeyAsString'],\n          ['verified', 'u8'],\n          ['share', 'u8'],\n        ],\n      },\n    ],\n    [\n      Metadata,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['updateAuthority', 'pubkeyAsString'],\n          ['mint', 'pubkeyAsString'],\n          ['data', Data],\n          ['primarySaleHappened', 'u8'], // bool\n          ['isMutable', 'u8'], // bool\n        ],\n      },\n    ],\n    [\n      EditionMarker,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['ledger', [31]],\n        ],\n      },\n    ],\n  ]);\n\n  async function createMetadata(\n    data,\n    updateAuthority,\n    mintKey,\n    mintAuthorityKey,\n    instructions,\n    payer,\n  ) {\n    const metadataProgramId = programIds.metadata;\n    const metadataAccount = (\n      await findProgramAddress(\n        [\n          Buffer.from('metadata'),\n          new PublicKey(metadataProgramId).toBuffer(),\n          new PublicKey(mintKey).toBuffer(),\n        ],\n        new PublicKey(metadataProgramId),\n      )\n    )[0];\n    \n    const value = new CreateMetadataArgs({ data, isMutable: true });\n\n    let txnData = Buffer.from(serialize(METADATA_SCHEMA, value));;\n    const keys = [\n      {\n        pubkey: new PublicKey(metadataAccount),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: new PublicKey(mintKey),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(mintAuthorityKey),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(payer),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(updateAuthority),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: new PublicKey(metadataProgramId),\n        data: txnData,\n      }),\n    );\n  \n    return metadataAccount;\n  }\n\n  async function updateMetadata(\n    data,\n    newUpdateAuthority,\n    primarySaleHappened,\n    mintKey,\n    updateAuthority,\n    instructions,\n    metadataAccount,\n  ) {\n    const metadataProgramId = programIds.metadata;\n  \n    metadataAccount =\n      metadataAccount ||\n      (\n        await findProgramAddress(\n          [\n            Buffer.from('metadata'),\n            new PublicKey(metadataProgramId).toBuffer(),\n            new PublicKey(mintKey).toBuffer(),\n          ],\n          new PublicKey(metadataProgramId),\n        )\n      )[0];\n\n    const value = new UpdateMetadataArgs({\n      data,\n      updateAuthority: !newUpdateAuthority ? undefined : newUpdateAuthority,\n      primarySaleHappened:\n        primarySaleHappened === null || primarySaleHappened === undefined\n          ? null\n          : primarySaleHappened,\n    });\n    const txnData = Buffer.from(serialize(METADATA_SCHEMA, value));\n    const keys = [\n      {\n        pubkey: new PublicKey(metadataAccount),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: new PublicKey(updateAuthority),\n        isSigner: true,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: new PublicKey(metadataProgramId),\n        data: txnData,\n      }),\n    );\n  \n    return metadataAccount;\n  }"]},"metadata":{},"sourceType":"module"}